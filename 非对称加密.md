作者：ThreatHunter

链接：https://www.zhihu.com/question/33645891/answer/192604856

举一个小学生都能懂的例子吧：

-----------------------------

看一个小时候经常在《趣味数学》这类书里的一个数学小魔术：

让对方任意想一个 3 位数，并把这个数和 91 相乘，然后告诉我积的最后三位数，我就可以猜出对方想的是什么数字啦！比如对方想的是 123，那么对方就计算出 123 * 91 等于 11193，并把结果的末三位 193 告诉我。看起来，这么做似乎损失了不少信息，让我没法反推出原来的数。不过，我仍然有办法：只需要把对方告诉我的结果再乘以 11，乘积的末三位就是对方刚开始想的数了。可以验证一下，193 * 11 = 2123，末三位正是对方所想的秘密数字！

其实道理很简单，91 乘以 11 等于 1001，而任何一个三位数乘以 1001 后，末三位显然都不变（例如 123 乘以 1001 就等于 123123）。

知道原理后，我们可以构造一个定义域和值域更大的加密解密系统。比方说，任意一个数乘以 400000001 后，末 8 位都不变，而 400000001 = 19801 * 20201，于是你来乘以 19801，我来乘以 20201，又一个加密解密不对称的系统就构造好了。

甚至可以构造得更大一些：4000000000000000000000000000001 = 1199481995446957 * 3334772856269093，这样我们就成功构造了一个 30 位的加密系统。

这是一件非常 coooooooool 的事情，任何人都可以按照我公布的方法加密一个数，但是只有我才知道怎么把所得的密文变回去。

其安全性就建立在算乘积非常容易，但是要把 4000000000000000000000000000001 分解成后面两个数相乘，在没有计算机的时代几乎不可能成功！但如果仅仅按照上面的思路，如果对方知道原理，知道我要构造出带很多 0 的数，根据 19801 和 8 位算法这 2 个条件非常容易穷举出 400000001 这个目标值。

要解决这个问题，真实世界就不是使用乘法了，比如 RSA 算法使用的是指数和取模运算，但本质上就是上面这套思想。