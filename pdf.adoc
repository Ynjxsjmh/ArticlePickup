= PDF 文本格式
作者：未知 编辑：Ynjxsjmh
:toc: left
:toclevels: 4
:stem: latexmath
:imagesdir: ./img/PDF
:source-highlighter: coderay
:experimental:

编者按： 一系列关于 PDF 不错的文章，整理自 PDF Tech，一个已经凉了的网站，作者不详。感觉里面有些例子是来自国外的，比如那个绘制简单图形的源 PDF 的注释都是英文的。

== 前言

便携式文档格式（英语：Portable Document Format，缩写：PDF）在我们电子办公生活中无处不在，它给我们留下的印象是它难以复制、难以更改的特性。想要了解为什么如此，大家可以看 https://type.cyhsu.xyz/2018/09/understanding-pdf-the-digitalized-paper/[这篇文章]。

有关 PDF 文档格式的标准已在 2008 年被收入到 https://www.iso.org/standard/51502.html[ISO 32000 标准]中。

PDF 标准指定了一种电子文档的数字表示性形式，让用户能够交换和查看电子文档，而不依赖于该文档的创建环境或者查看及打印环境。

有了这份标准，开发人员就有了创建符合规范 PDF 文档的依据，有了读取显示现有 PDF 文档的依据。

可是标准也没有指定所有的一切，如下的内容标准并没有给出约定，需要软件开发者自己实现：


* 将纸张或电子文档转换为 PDF 格式的具体过程
* 页面渲染过程的具体技术设计、软件用户界面、软件实现或操作细节
* 某些文档（如多媒体）的具体物理存储方法和存储条件
* 阅读器验证 PDF 文件需要遵从的方法
* 需要的计算机或者操作系统

700 多页的 PDF 标准文件内容很多，不过结构还是很清晰的，概括起来主要是分为这么几块：

. PDF 的语法：语法约定了 PDF 文件所用到的关键词汇，定义了 PDF 的对象类型、滤镜、文件结构、加密、文档结构、内容流和资源、函数、文件规范、扩展字典等
. PDF 的图形：介绍了图形对象、坐标图形状态、路径（Path）的构建和绘制、颜色空间、图案、外部对象、图像、表单 XObjects、可选内容
. PDF 的文本：字体如何组织和使用、文本状态参数和运算符、文本对象、字体数据结构简介、简单字体、复合字体、字体描述符、嵌入字体程序、如何提取文本内容
. PDF 的渲染：这是最吃功力的部分了，因为渲染就是显示，介绍了基于 CIE 色彩到设备色彩、设备色彩空间之间的转换、传递函数、半色调、扫描转换等
. PDF 透明度：透明度组、复合计算、软蒙版、如何在 PDF 中指定透明度、色彩空间和渲染问题
. PDF 的交互功能：阅读器的首选项、文档级导览、页面级导览、批注、动作、交互式表单、数字签名、测量属性、文档要求
. PDF 的多媒体特性：多媒体、音频、视频、替代演示文稿（就是替代 PPT）、3D 支持
. PDF 文档交换：定义了过程集、元数据、文件标识符、页片字典、标记内容、逻辑结构、加标签的 PDF、可访问性支持、网页捕捉、印前支持。
 
这么多的内容看起来着实让人一下子摸不着头脑，我们就从一个手写 PDF “Hello World” 例子开始，来逐步解开 PDF 标准的神秘面纱。

== 手写 PDF 实例

[source, pdf]
----
% 下面是一份手写 PDF 文件，只需要用记事本保存这份文档为 PDF 文件就可
% PDF-1.4
 
1 0 obj
<<
/Type /Pages
/Kids [2 0 R]
/Count 1
>>
endobj
 
2 0 obj
<<
/Type /Page
/Parent 1 0 R
/MediaBox [0 0 612 792]
/Contents 4 0 R
/Resources
<<
/Font
<<
/Font1 5 0 R
>>
/XObject <<
/Image1 6 0 R
>>
>>
>>
endobj
 
3 0 obj
<<
/Type /Catalog
/Pages 1 0 R
>>
endobj
 
4 0 obj
<<
/Length 0
>> stream
1 0 0 RG
0 792 m
612 0 l
s
 
BT
/Font1 10 Tf
100 700 TD
(Hello World!) Tj
ET
 
q
100 0 0 100 300 600 cm
/Image1 Do
Q
endstream
endobj
 
5 0 obj
<<
/Type /Font
/Subtype /Type1
/BaseFont /Helvetica
>>
endobj
 
6 0 obj<<
/Type /XObject
/Subtype /Image
/Width 8
/Height 8
/ColorSpace /DeviceRGB
/BitsPerComponent 8
/Length 0
/Filter /ASCIIHexDecode
>> stream
FF0000 C00000 A00000 800000 600000 400000 200000 0000FF
FF2000 C00000 A00000 800000 600000 400000 200000 0000C0
FF4000 C00000 A00000 800000 600000 400000 200000 0000A0
FF6000 C00000 A00000 800000 600000 400000 200000 000080
FF8000 C00000 A00000 800000 600000 400000 200000 000060
FFA000 C00000 A00000 800000 600000 400000 200000 000040
FFC000 C00000 A00000 800000 600000 400000 200000 000020
FFFF00 C0C000 A0A000 808000 606000 404000 202000 000000>
endstream
endobj
 
xref
trailer
<<
/Size 0
/Root 3 0 R
>>
startxref
%%EOF
----

这段代码在阅读器的渲染后，我们可以看到一条红色的直线、Hello Word 文本、还有一块多彩的图案。

[.text-center]
image::hello_world.png[]

是不是很神奇呢？下面我们就着这份手写 PDF 源文件对 PDF 文件格式做一个简单介绍。

== 分析

想象一下，假如你是 PDF 阅读器，你会怎样来“读懂”这样一份 PDF 源码呢？我们就先来按照阅读器的“思路”分析一下这份 PDF 源码。

. 阅读器会在文件中搜寻关键字 `%PDF-`，因为 PDF 语法中定义了所有的 PDF 文件在文件头的部分都必须包含这个标识符，这个标识符可以用来快速鉴别文档是否是 PDF 文档。
+
[.text-center]
image::pdf-identifier.png[identifier]

. 阅读器会遍历整个文件找到 PDF 文件尾的一个关键字 `trailer`
+
[.text-center]
image::pdf-trailer.png[trailer]
+
在这个关键字后面的 `<<` 中你一定会发现一个根节点(/Root)。可不要小看这个节点，俗话说牵一发而动全身，这个根(/Root)节点就是整个 PDF 文件的入口，所有的阅读器都是从这个入口进入，然后拔出萝卜带出泥的。
+
[.text-center]
image::pdf-root.png[root]

. 因为没有介绍过 PDF 的语法，所以这里大家会看到一句
+
[source, pdf]
----
/Root 3 0 R
----
+
这表示的意思是说，这篇文档的根节点 /Root 它指向了一个对象，这个对象的编号是 3 0
+
R 这里表示一个间接引用，如果你学习过 C 语言这就是一个指针，它指向了一个对象，这个对象就是在文件体里面 `3 0 obj ...... endobj` 之间包含的内容。
+
[.text-center]
image::3-0-obj.png[]

说到这里大家是不是可以看出来其实 PDF 的文件结构的主体就是三部分构成的。

. 文件头就是含有关键字 `%pdf-`
. 文件体就是由一个个 `X X obj …… endobj` 顺序排列而成
. 文件尾是由 `交叉引用表` 和 `文件尾` 构成。

如下图：

[.text-center]
image::structure.jpg[文件结构]

好了，这里补充一下什么是交叉引用表？

交叉引用表的出现是因为一个 PDF 文件的文件体（Body），可能含有非常大数量的文件体对象组成，这些对象都由 `XX XX obj` 开头，`endobj` 结束。这些对象之间互相链接，相互嵌套形成了一个树状的结构。

为了能够让阅读器快速的定位到 `XX XX obj` 这个对象，交叉引用表把所有的文件体对象在文件中的偏移位置做了记录，这样阅读器就可以快速的定位文件体对象了。

严格来说我给出的 PDF 源文件是缺失了交叉引用表的，可是因为现在的阅读器考虑到兼容性，对缺失了交叉引用表的 PDF 文件都可以自动恢复，所以该文件依旧是可以打开的。

我们接着来分析 Hello World 文件，我们注意到在 3 0 obj 这个文件体对象中，有如下的标识符：

* `/Type /Catalog` 表示这个对象体类型是这个 PDF 文档的目录
* `/Pages 1 0 R` 表示这个 PDF 文档的页面信息在对象体 1 0 obj 里面

[.text-center]
image::3-0-obj.png[]

为了分析这个页面信息是什么，于是我们又跳转到了 1 0 obj

[.text-center]
image::1-0-obj.png[]

1 0 obj 透露出的信息告诉我们这个对象体的类型是页面树，它的子节点是 2 0 obj，这篇 PDF 文档的页码总数是 1。你看出来了没有？

我们继续跳转到子节点 2 0 obj

[.text-center]
image::2-0-obj.png[]

这里我们可以看到，这个对象体的类型是一个具体的页面，这个页面对象体的父节点是 1 0 obj，它的页面大小是 612X792 基本单位，这个页面的内容在 4 0 obj 对象体内。这个页面的资源有两个，一个字体资源在 5 0 obj 对象体中，一个 XObject 资源在 6 0 obj 对象体中。

我们继续前往 4 0 obj，5 0 obj，6 0 obj 一探究竟。

先来看 4 0 obj

[.text-center]
image::4-0-obj.png[]

这个 4 0 obj 描述了三个页面内容，就分别是

. 一条红色的直线
+
[source, pdf]
----
1 0 0 RG
0 792 m
612 0 l
s
----
+
** 1 0 0 RG 说明 RGB 通道 R 分量为 1 就是 255，其余 GB 两个颜色分量为 0 红色。
** 0 792 m 就是移动（move）当前坐标点到 0 792 的位置，这个位置依据 PDF 的坐标，就是在页面的左上角。因为 PDF 坐标系的坐标原点在左下角点。
** 612 0 l 就是绘制直线（line）从当前坐标点到 612 0，也就是页面的右下角点。
** s 就是立即执行这个绘制（stroke）

+
好了这条红色的直线描述完成

. 还有 Hello World 文字输出
+
[source, pdf]
----
BT
/Font1 10 Tf
100 700 TD
(Hello World!) Tj
ET
----
+
开始输出一段文字，字体为 Font1 字号 10，输出从 100 700 这个坐标点开始
+
输出的内容就是园括弧里面的 Hello World！
+
BT 和 ET 分别就是 Begin Text 和 End Text 的简写。

. 还有一个多彩的图案
+
[source, pdf]
----
q
100 0 0 100 300 600 cm
/Image1 Do
Q
----
+
cm 运算符是进行坐标矩阵变换的，它将当前的坐标系进行了 Matrix 为（100,0,0,100,300,600）的矩阵变换，然后输出图案 Do。

最后我们看看两个被页面用到的资源

. 字体 Font1 的定义
+
[.text-center]
image::5-0-obj.png[]
+
Font1 字体定义为 Helvetica 字体

. 图像 Do 的定义
+
[.text-center]
image::6-0-obj.png[]
+
这幅图像被定义为了一幅长宽是 8X8 的图像，颜色空间 RGB 每个颜色分量 8bit，采用 ASCIIHex 编码，FF0000 这就是红色，你看明白没？

现在我们初步读懂了这个完整的 PDF 源文件。

== PDF 的基础语法之-基本数据类型

如果想要更进一步的探寻 PDF 的秘密，那么详细的了解 PDF 的语法是首要的任务，我们接下来就先来熟悉一下 PDF 的基础语法之-基本数据类型。

我们知道每种计算机语言为了能够准确的表达数据，都需要定义数据结构，而 PDF 语法也同样定义了 8 种基本的数据类型。

在详细介绍这 8 种数据类型前，我们先从最基本的层面来讲一下 PDF 文件。

PDF 文件其实就是一个字节序列，一些特定的字节可以分组为标记（tokens），一个或者多个标记组合起来，形成了更高级的语义实体（主要为对象），它们也就是 PDF 文档的基本数据值的构成。

如果 PDF 文件没有被加密，那么完全可以使用 ANSI 字符集的可视打印子集相对应的字节值，以及空白字符来表示。但是 PDF 文件不仅限于包含 ASCII 字符集，它还可以包含任意字节。

在 PDF 语法中有着如下的约定：
* 分隔对象和描述 PDF 文件结构的标记必须使用 ASCII 字符集，所有的关键字以及数字类型中的键名都应该使用 ASCII 字符集
* 字符串和流对象的数据值可以完全使用 ASCII 字符集编写，也可以完全使用二进制编写。比如图像数据（通常会使用二进制值表示，这样会更加简洁和高效）。
* 包含二进制数据的 PDF 文件必须作为二进制文件传输，而不是作为文本文件传输，以确保文件的所有字节都忠实的保留下来。

好了，我们了解了这些接下来就来看看八种基本对象类型吧。

=== 布尔对象

布尔对象表示真和假的逻辑值，它们在 PDF 文件中显示为关键字 true 和 false。

=== 数字对象

PDF 提供了两种类型的数字对象：整数和实数

整数写为一个或者多个十进制数，可以选择在前面添加一个符号

示例：123 43445 +17 -98 0

实数值写为一个或者多个十进制数和一个可选的符号，以及一个前导、结尾或者嵌入的句点（小数点）

示例：34.5 -2.63 +123.6 4. -.002 0.0

=== 字符串对象

字符串对象包含 0 个或者多个字节，字符串对象不是整数对象，但是以一种更加紧凑的格式存储。

字符串对象采用下面两种方式之一编写：

1. 作为包含在 `圆括号()` 内的一个文字字符序列

示例：以下是有效的字符串

[source, pdf]
----
( This is a string )
( Strings may contain newlines
and such . )
( Strings may contain balanced parentheses ( ) and special characters ( * ! & } ^ % and so on ) . )
( The following is an empty string . )
()
( It has zero ( 0 ) length. )
----

文字字符串中支持转义序列

|===
| 序列 | 含义

| \n
| LINE FEED（0Ah）（LF）

| \r
| CARRIAGE RETURN（0Dh）（CR）

| \t
| HORIZONTAL TAB（09h）（HT）

| \b
| BACKSPACE（08h）（BS）

| \f
| FORM FEED（FF）

| \(
| LEFT PARENTHESIS（28h）

| \)
| RIGHT PARENTHESIS（29h）

| \\
| REVERSE SOLIDUS（5Ch）（反斜杠）

| \ddd
| 字符编码 ddd（八进制）
|===

编写器可以将一个文字字符串放在多行上。位于行末的反斜杠字符用于指示字符串会在下一行继续在读取字符串时，阅读器忽略反斜杠字符和它之后的行结束标记，得到的字符串值等效于字符串未被分割时的读取结果。

示例：

[source, pdf]
----
( These \
two strings \
are the same . )
----

等同于

[source, pdf]
----
( These two strings are the same. )
----

[start=2]
. 作为包含在 `尖括号<>` 中的十六进制数据

字符串也可以编写为十六进制形式，这对于在 PDF 文件中包含任意二进制数据很有用。十六进制字符串编写为一个十六进制数字（0～9 和 A～F 或 a～f）序列，它们编码为 ASCII 字符并包含在尖括号中。

示例 1 < 4E6F762073686D6F7A206B6120706F702E >
 
每对十六进制数定义字符串中的一个字节。空白字符（如 SPACE（20h）、HORIZONTAL TAB（09h）、CARRIAGE RETURN（0Dh）、LINE FEED（0Ah）和 FORM FEED（0Ch））应被忽略。

如果缺失了十六进制字符串的最后一位，也就是说，如果字符串中有单数个数字，那么最后的数字应假设为 0。


示例： < 901FA3 > 是一个 3 字节字符串，包含十六进制编码为 90、1F 和 A3 的字符

< 901FA > 也是一个 3 字节字符串，但它包含十六进制编码为 90、1F 和 A0 的字符。

=== 名称对象

这种对象在 PDF 源文件里面几乎无处不在，它有别于字符串对象。因为它的用途并不是为了显示一段文本。

它由一个 `斜杆/` 作为前缀，后面跟着的字符序列表示名称。

|===
| 文字名称的语法 | 生成的名称

| /Name1
| Name1

| /ASomewhatLongerName
| ASomewhatLongerName

| /A;Name_With-Various***Characters?
| A;Name_With-Various***Characters?

| /1 . 2
| 1.2

| /$$
| $$

|/@pattern
| @pattern

| /. notdef
| . notdef

| /lime#20Green
| Lime Green

| /paired#28#29parentheses
| 成对的圆括号()

| /The_Key_of_F#23_Minor
| The_Key_of_F#_Minor

|/A#42
| AB
|===

这里特别注意的是，可以用#后跟 16 进制数表示 ASCII 码中的相应字符，#本身用#23 表示。

=== 数组对象

数组对象是一种一唯对象集合，它可以由不同类型的对象组合在一起。也就是它支持异构，数组元素可以是数字、字符串、字典、甚至其他数组构成。如果需要更高唯的数组可以用数组嵌套来完成，可以嵌套到任何深度。

[source, pdf]
----
[ 549 3.14 false ( Ralph ) /SomeName]
----

这个数组就是由整数、小数、布尔值、字符串、名称构成的，你看明白了吗？

需要特别注意的是：数组需要用 `一对方括号[ ]` 包含起来。

=== 字典对象

字典对象也是一种组合对象，它是成对出现的。它是包含对象对的关联表。字典的每个条目，它的第一个元素是“键”，第二个元素是“值”。键的类型必须是一个名称，值可以是任何类型。

字典表示出一个关联表，里面的条目是无序的，在同一个字典里，不同的条目不应该具有相同的键。

字典对象被包含在 `一对双尖括号<< >>` 中，并且可以嵌套。

[source, pdf]
----
<<  /Type  /Example
/Subtype /DictionaryExample
/Version 0 . 01
/IntegerItem  12
/StringItem  ( a string )
/Subdictionary  << /Item1 0 . 4
                         /Item2  true
                         /LastItem  ( not ! )
                         /VeryLastItem  ( OK )
                         >>
>>
----

=== 流对象

与字符串对象一样，流对象是一个字节序列。而且流对象没有长度限制，而字符串会受到实现的限制。因此有可能包含大量数据的对象（图像或者页面描述）会表示为流。

流对象包含有一个字典，后面再跟着包含在 stream 和 end stream 之间的 0 或者多个字节：

示例：

[source, pdf]
----
dictionary
stream
0 或者多个字节
endstream
----

在流对象的字典里，会有一些公共条目，这些公共条目就是字典对象，我们从这些公共条目以及它的值就可以判断出这个内容流的一些基本信息，比如长度、滤镜、参数、等等。阅读器就是依靠这些信息才能读懂这是什么一个内容流。

=== NULL 对象

null 对象的类型和值不等于任何其他对象。使用关键字 null 表示，如果引用了一个不存在的对象，就视同为引用了一个 null 对象。

=== 特别的类型：间接对象

PDF 文件中的任何对象都可以标记为间接对象，它为对象提供了唯一的标识符，其他对象可以通过它来引用该对象。对象表示如下：


* 一个正整数对象编号
* 一个非负整数代号。在新创建的 PDF 文件中所有的间接对象都为代号 0，当以后文件更新，可以引入非 0 代号 ，后面我们详细介绍交叉引用表和增量更新的时候会介绍

示例  下面展示了使用间接对象来指定流的长度。流的 Length 条目的值是一个整数对象，在文件中紧跟在流之后。这使一次性生成 PDF 的应用程序可以推后指定流的长度，直到其内容生成完毕后再指定。

[source, pdf]
----
7 0 obj
<< /Length 8 0 R >>  % 一个间接对象指向了 8
BT
/F1 12 Tf
72 712 Td
( A stream with an indirect length ) Tj
ET
endstream
endobj


8 0 obj
77  % 流的长度
endobj
----


== PDF 标准之文本篇

=== 概述

在 PDF 标准中，文本、图形、图像占据了重要的篇幅。

在 PDF 版式技术中，文本字形的渲染要比 Word 中更加丰富、渲染手段也更加复杂。

简单来说，字形就是一种图形，可以对它进行任何图形处理操作，比如调整变形。由于文本在大多数页面描述中都非常重要，PDF 提供了高级工具来简单高效地描述、选择和渲染字形。

在 PDF 的标准中文本的阐述将会在下面这个三个主题中展开：

* _文本状态_。文本状态是有关文本的一个图形状态参数子集，包括选择字体、将字形缩放到适当大小，以及完成其他图形效果的参数。
* _文本对象和运算符_。文本运算符指定将要绘制的字形，由字符串对象表示，这些对象的值将被解释为字符编码序列。文本对象将一个文本运算符序列和相关的参数封装起来。
* _字体数据结构_。字体字典和相关的数据结构为合格阅读器提供正确渲染文本和适当地放置字形所需的信息。字形本身的定义将包含在字体程序中，字体程序可能嵌入在 PDF 文件中，内置于合格阅读器中，或者取自外部字体文件。

在此之前我们先来看看 PDF 是如何在页面上绘制字体的字形的？

=== 在页面上绘制字体的字形

**字符**是抽象的符号，而**字形**则是字符的具体图形化渲染。

示例 1 字形 A、**A** 和 __A__ 是抽象的“A”字符的渲染。

备注 1 从历史上看，这两个术语在计算机印刷领域经常互换使用（有某些 PDF 字典键和 PostScript 运算符使用的名称为证），但是该领域的发展使得区别使用变得更有意义，因此现在可以根据本标准区分字符和字形，只有一些旧有名称未能保持一致。

字形被组织成字体。**字体**定义一个特定字符集的字形。

示例 2 Helvetica 和 Times 字体定义标准拉丁语字符集的字形。

与合格阅读器一起使用的字体以程序的形式存在。这种字体程序 由专用语言写成（如 Type 1、TrueType 或者 OpenType 字体格式），可由专用字体解释器识别。

在 PDF 中，术语__字体__指__字体字典__，即一个 PDF 对象，标识字体程序并包含有关字体程序的其他信息。有几种不同的字体类型，由字体字典的 **Subtype** 条目标识。

对于大多数字体类型，字体程序将在一个单独的__字体文件__中定义，该字体文件或者嵌入在 PDF 流对象中，或者从外部源获得。字体程序包括生成字形的__字形描述__。

备注 2 熟悉一般形状扫描转换的程序员可能会关心此描述需要的计算量。但是，这只是字形描述和字体程序的抽象行为，而不是它们的实现方法。事实上，可以通过缓存并重用之前渲染的字形来达到有效的实现。

内容流通过指定字体字典和字符串对象来在页面上绘制字形，其中的字符串对象将被转换为一个或多个字符编码来标识字体的字形。该操作称为显示 文本字符串，以这种方式绘制的文本字符串称为显示字符串。字形描述由一系列图形运算符组成，这些运算符生成字体中字符的具体形状。要渲染字形，合格阅读器应执行字形描述。

示例 1 我们来看一个实际的例子，PDF 是如何显示“文本 ABC 置于距页面底部 10 英寸、页面左侧边缘 4 英寸的位置，使用 12 点大的 Helvetica。”

[source, pdf]
----
BT
/F13 12 Tf
288 720  Td
( ABC ) Tj
ET
----

本示例中的五行代码执行下列步骤：

. 开始一个文本对象。
. 设置使用的字体和字体大小，将它们设置为文本状态中的参数。在本示例中，标识为 F13 的字体资源指定外部称为 Helvetica 的字体。
. 在页面上指定起始位置，设置文本对象中的参数。
. 在指定的位置绘制字符字符串的字形。
. 结束文本对象。

要绘制字形，内容流要首先将字体标识为已使用。**Tf** 运算符将指定字体资源的名称——即指定当前资源字典的 **Font** 子字典中的一个条目。该条目的值将是一个字体字典。字体字典将标识字体的外部已知名称，比如 Helvetica，同时将提供一些合格阅读器绘制字体的字形所需的其他信息。字体字典可提供字体程序本身的定义。

备注 1 出现在 **Tf** 运算符中的字体资源名称是任意的，就如同各类资源的名称一样。该名称与实际字体名称如 Helvetica 毫无关系。

示例 2 本示例演示当前页面的资源字典中的一段摘要，该片断定义引用为 F13（参见本节的示例 1）的字体字典。

[source, pdf]
----
/Resources
<<  /Font << /F13  23 0 R  >>
>>
23 0  obj
<<  /Type /Font
/Subtype  /Type1
/BaseFont /Helvetica
>>
endobj
----

字体以一个标准大小定义字形。指定该标准是为了将排列紧凑的文本行高设置为 1 个单位。在默认的用户坐标系中，这意味着标准字形大小是 1 单位用户空间，即 1/72 英寸。从 PDF 1.6 起，可以通过页面字典的 **UserUnit** 条目将该单位大小指定为大于 1/72 英寸。标准大小字体进而可能缩放到可用的大小。缩放因子被指定为 **Tf** 运算符的第二个操作数，通过它设置图形状态中的__文本字体大小__参数。本节的示例 1 使用图形状态的 12 单位大小建立了 Helvetica 字体。

选择好字体并进行缩放后，就可以使用它来绘制字形。**Td** 运算符将调整文本矩阵的平动分量，如 9.4.2“文本定位运算符”所述。当在 **BT** 之后执行第一次操作时，**Td** 将在当前用户坐标系中确定文本位置，即在页面上确定开始绘制字形的位置。

**Tj** 运算符将获取一个字符串操作数并绘制相应的字形，该过程使用当前字体和图形状态中其他与文本相关的参数。

备注 2 **Tj** 运算符将所字符串的每个元素（0到 255 之间的一个整数）都当作字符编码（参见本节中的示例 1）。

每个字节选择字体中的一个字形描述，PDF 执行字形描述来在页面上绘制字形。这是简单字体（比如普通的拉丁语文本字体）的 **Tj** 行为。对于复合字体来说，将字符串转换为字符编码序列的过程较为复杂，如 9.7“复合字体”所述。

通过这些步骤在页面上绘制的不是 __12 点__字形，而是 __12 单位__字形，其中单位大小是字形渲染到页面上时的文本空间。字形的实际大小由文本对象中的文本矩阵（Tm）、几个文本状态参数，以及图形状态中的当前转换矩阵（CTM）确定。

示例 3 如果以后对文本空间进行缩放，将单位大小设置为 1 厘米，使用 12 单位的字体绘制出的字形将高 12 厘米

至此我们介绍完了如何在 PDF 页面中显示普通文本。是不是很简单？

那么如何才能实现特殊的图形效果的文本呢？

=== 实现特殊的图形效果的文本


我们来看这么一个例子：

[.text-center]
image::half-gray.jpg[]

上面这个 50%灰的文本是在 PDF 里面是这么表达的：

[source, pdf]
----
BT
/F13  48 Tf
20 40 Td
0 Tr
0.5  g
( ABC )  Tj
ET
----

使用 Tj 和其他字形绘制运算符绘制出的是填充黑色的字形。其他效果可通过结合使用字体运算符和一般图形运算符来实现。

绘制字形使用的颜色将是图形状态中的当前颜色：根据文本渲染模式不同，可能是非描边颜色或描边颜色（或者同时使用这两种颜色）。默认颜色是黑色（DeviceGray），但是通过在绘制字形之前执行相应的颜色设置运算符，可以获得其他颜色。上图就是使用文本渲染模式 0 和 g 运算符来使用 50%灰填充字形。

我们再来看下面这个文本：

[.text-center]
image::blank-inside.jpg[]

[source, pdf]
----
BT
/F13 48 Tf
20 38 Td
1 Tr
2 w
( ABC ) Tj
ET
----

要实现其他图形效果，可以将字形轮廓当作路径而不是填充它。图形状态中的__文本渲染模式__参数指定是否填充字形轮廓、是否对字形轮廓进行描边、是否将字形轮廓用作剪切边界，或者这几种效果的组合。对于 Type 3 字体只能应用某几种渲染模式。

将字形轮廓当作要描边的路径。运算符 Tr 将文本渲染模式设置为 1（描边）。运算符 w 将线条宽度设置为 2 单位用户空间。给定这些图形状态参数后，Tj 运算符将使用 2 点宽的线条对字形轮廓进行描边。

再来看一个例子：

[.text-center]
image::starburst.jpg[]

[source, pdf]
----
BT
/F13 48 Tf
20 38 Td
7 Tr
( ABC ) Tj
ET
----

演示如何将字形轮廓用作剪切边界。Tr 运算符将文本渲染模式设置为 7（剪切），使得后面的 Tj 运算符将字形轮廓当作当前剪切路径。所有后续的绘制操作都将只在该路径内标记页面，如图所示。这种状态会一直持续到使用 Q 运算符让原先设置的剪切路径恢复正常。

是不是很有趣呢？


== 完成一个图形的 PDF 文件


先来看一下效果

[.text-center]
image::绘制简单图形.png[]

再来看源码：

[source, java]
----
%PDF-1.4
1 0 obj
<<
/Type /Catalog
/Outlines  2 0 R
/Pages  3 0 R
>>
endobj

2 0 obj
<<
/Type /Outlines
/Count 0
>>
endobj

3 0 obj
<<
/Type /Pages
/Kids  [ 4 0 R ]
/Count 1
>>
endobj

4 0 obj
<<
/Type /Page
/Parent  3 0 R
/MediaBox  [ 0  0 612 792 ]
/Contents  5 0 R
/Resources
/ProcSet 6 0 R
>>
endobj

5 0 obj
<<
/Length  883
>>
stream
% 绘制一个黑色的线段，使用默认的线宽
150  250 m
150  350 l
S

% 绘制有厚度的虚线线段。
4 w % 设置线宽为 4 个单位
[ 4 6 ]  0 d % 设为虚线样式，以 4 个单位连续， 6 个单位断开
150  250 m
400  250 l
S
[ ]  0 d % 复位虚线图案为实线
1 w % 复位线宽度为 1 个单位

% 绘制了 1 个单位红色边框的矩形，填充淡蓝色。
1.0 0.0 0.0 RG % 为红色描边颜色
0.5 0.75  1.0 rg % 淡蓝色的填充
200 300  50  75  re
B

% 绘制曲线灰色填充和彩色边框。
0.5 0.1 0.2 RG
0.7 g
300 300  m
300 400  400 400 400 300 c b
endstream
endobj

6  0 obj
[/PDF]
endobj

xref
0  7
0000000000  65535 f
0000000009  00000 n
0000000074  00000 n
0000000120  00000 n
0000000179  00000 n
0000000300  00000 n
0000001532  00000 n

trailer
<<
/Size  7
/Root  1 0 R
>>
startxref
1556
%%EOF
----


为了便于大家理解我附上曲线操作符

[caption=]
[%autowidth.stretch]
.路径构建运算符
|===
| 操作数 | 运算符 | 描述

| x y
| m
| 通过将当前点移动到坐标(x, y)开始一个新的子路径，省略任何连接线段。如果当前路径中的上一个路径构建运算符也是 m，则新 m 重写它；路径中不保留任何之前 m 操作的痕迹。

| x y
| l（小写 L）
| 从当前点追加一条直线到点(x, y)。新的当前点应该是(x, y)。

| x1  y1  x2  y2  x3  y3
| c
| 向当前路径追加三次贝塞尔曲线。该曲线从当前点延伸到点(x3, y3)，使用(x1, y1)和(x2, y2)作为贝塞尔控制点（参见 8.5.2.2“三次贝塞尔曲线”）。新的当前点应该是(x3, y3)。


| x2  y2  x3  y3
|v
| 向当前路径追加三次贝塞尔曲线。该曲线从当前点延伸到点(x3, y3 )，使用当前点(x2, y2)作为贝塞尔控制点（参见 8.5.2.2“三次贝塞尔曲线”）。新的当前点应该是(x3, y3)。

| x1  y1  x3  y3
| y
| 向当前路径追加三次贝塞尔曲线。该曲线从当前点延伸到点(x3, y3)，使用(x1, y1)和(x3, y3)作为贝塞尔控制点（参见 8.5.2.2“三次贝塞尔曲线”）。新的当前点应该是(x3, y3)。

| —
| h
| 从当前点子路径将一条直线追加到子路径的起点，封闭当前的子路径。如果当前子路径已经封闭，则 h 不执行任何操作。

此运算符将终止当前的子路径。向当前路径追加另一条线段将开始一个新路径，即使新线段从 h 操作的结束点开始。

| x  y  width height
| re
| 将一个矩形追加到当前路径作为一个完整的子路径，左下角为(x, y)，使用用户空间中的维度宽度和高度。

操作 x  y  width height re 等效于 x  y m( x + width ) y  l( x + width )  ( y + height ) lx  ( y + height ) l  h
|===


== 参考资料

https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F[可移植文档格式]

https://github.com/galkahana/HummusJS/wiki

